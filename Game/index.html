<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Бесконечная платформа — полёт + перетаскивание (моб.)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  <style>
    html,body{
      height:100%;
      margin:0;
      background:#0b1020;
      color:#ddd;
      font-family:'Inter', Arial, sans-serif;
      overflow: hidden;
    }
    #app{
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
    }
    .hud{
      position:fixed;
      right:10px;
      top:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index:20;
    }
    .btn{
      background:rgba(0,0,0,0.4);
      backdrop-filter:blur(6px);
      -webkit-backdrop-filter:blur(6px);
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px;
      border-radius:10px;
      color:#fff;
      font-size:14px;
      font-weight: 500;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, border-color 0.2s, color 0.2s;
    }
    .btn:active {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }
    .btn.active { /* Для активных режимов, например, создания */
        color: #ffcc00;
        border-color: #ffcc00;
    }
    .small{
      padding:6px 8px;
      font-size:13px;
    }
    #joystick{
      position:fixed;
      left:12px;
      bottom:12px;
      width:120px;
      height:120px;
      border-radius:60px;
      background:rgba(255,255,255,0.04);
      z-index:20;
      touch-action:none;
      user-select: none;
    }
    #joystick::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      width: 50px; /* Немного уменьшил */
      height: 50px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.1s;
    }
    #thruster{
      position:fixed;
      right:12px;
      bottom:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index:20;
      user-select: none;
    }
    .thr-btn{
      width:72px;
      height:48px;
      border-radius:8px;
      background:rgba(255,255,255,0.04);
      display:flex;
      align-items:center;
      justify-content:center;
      touch-action:none;
      color: #fff;
      font-size: 20px;
      transition: background 0.1s;
    }
    .thr-btn:active {
      background: rgba(255, 255, 255, 0.1);
    }
    #editorPanel{
      position:fixed;
      left:50%;
      top:8px;
      transform:translateX(-50%);
      background:rgba(0,0,0,0.55);
      backdrop-filter:blur(6px);
      -webkit-backdrop-filter:blur(6px);
      padding:10px;
      border-radius:10px;
      z-index:30;
      display:flex;
      gap:8px;
      align-items:center;
    }
    label{
      font-size:13px;
      color:#fff;
      user-select: none;
    }
    input[type=color]{
      width:36px;
      height:28px;
      padding:0;
      border:0;
      border-radius: 4px;
      overflow: hidden;
    }
    select {
      background: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 4px;
      font-size: 13px;
    }
    .footerTip{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      padding:8px;
      text-align:center;
      color:#999;
      font-size:12px;
      background: rgba(0,0,0,0.2);
      user-select: none;
    }
  </style>
</head>
<body>
<div id="app">
  <div id="container"></div>

  <div class="hud">
    <button id="timeBtn" class="btn small">Остановить время</button>
    <button id="openEditor" class="btn small">Открыть редактор</button>
  </div>
  
  <div id="joystick"></div>
  
  <div id="thruster">
    <div id="upBtn" class="thr-btn">▲</div>
    <div id="downBtn" class="thr-btn">▼</div>
  </div>
  
  <div id="editorPanel" style="display:none">
    <label>Примитив:</label>
    <select id="primType"><option value="box">Box</option><option value="sphere">Sphere</option></select>
    <label>Цвет:</label>
    <input type="color" id="primColor" value="#ffcc00">
    <button id="addPrim" class="btn small">Создать объект</button>
    <button id="closeEditor" class="btn small">Закр.</button>
  </div>
  
  <div class="footerTip">
    Управление: джойстик слева — движение, кнопки справа — вверх/вниз. <br/>
    Долгое касание на объекте — перетащить. Короткое касание — создать объект в точке (если активирован режим создания).
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
<script type="module">
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

  // --- Сцена и рендер ---
  const container = document.getElementById('container');
  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0f1a);
  scene.fog = new THREE.Fog(0x0a0f1a, 50, 200);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);

  // light
  const hemi = new THREE.HemisphereLight(0xffffee, 0x222233, 0.9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5,10,2);
  scene.add(dir);

  // --- Физика ---
  const world = new CANNON.World({gravity: new CANNON.Vec3(0,-9.82,0)});
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.solver.iterations = 8;
  
  // Материалы физики
  const groundMatCannon = new CANNON.Material("groundMaterial");
  const objectMatCannon = new CANNON.Material("objectMaterial");
  const contactMaterial = new CANNON.ContactMaterial(groundMatCannon, objectMatCannon, {
      friction: 0.3,
      restitution: 0.3,
  });
  world.addContactMaterial(contactMaterial);


  // Пол — бесконечная платформа
  const groundGeo = new THREE.PlaneGeometry(2000,2000,1,1);
  const groundMat = new THREE.MeshStandardMaterial({color:0x1a2333, metalness:0.1, roughness:0.9});
  const groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI/2;
  scene.add(groundMesh);

  const groundBody = new CANNON.Body({
    mass:0, 
    shape: new CANNON.Plane(),
    material: groundMatCannon 
  });
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
  world.addBody(groundBody);

  const grid = new THREE.GridHelper(2000, 200, 0x223344, 0x182028);
  grid.material.transparent = true;
  grid.material.opacity = 0.5;
  scene.add(grid);

  // --- Игрок ---
  const player = {
    mesh: new THREE.Object3D(),
    velocity: new THREE.Vector3(0,0,0),
    radius: 0.6
  };
  player.mesh.position.set(0,3,5);
  scene.add(player.mesh);
  camera.position.set(0,0,0);
  player.mesh.add(camera);

  // --- Список динамических объектов ---
  const dynamic = [];
  const raycaster = new THREE.Raycaster(); // Создаем один раз

  function addPhysicalBox(pos, size, color){
    const geo = new THREE.BoxGeometry(size.x,size.y,size.z);
    const mat = new THREE.MeshStandardMaterial({color:color});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true; mesh.receiveShadow = true;
    mesh.position.copy(pos);
    scene.add(mesh);

    const shape = new CANNON.Box(new CANNON.Vec3(size.x/2,size.y/2,size.z/2));
    const body = new CANNON.Body({
      mass:1, 
      shape:shape, 
      position: new CANNON.Vec3(pos.x,pos.y,pos.z),
      material: objectMatCannon 
    });
    world.addBody(body);

    dynamic.push({mesh, body});
    return {mesh, body};
  }

  function addPhysicalSphere(pos, r, color){
    const geo = new THREE.SphereGeometry(r, 24, 18);
    const mat = new THREE.MeshStandardMaterial({color:color});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);

    const shape = new CANNON.Sphere(r);
    const body = new CANNON.Body({
      mass:1, 
      shape:shape, 
      position:new CANNON.Vec3(pos.x,pos.y,pos.z),
      material: objectMatCannon 
    });
    world.addBody(body);

    dynamic.push({mesh, body});
    return {mesh, body};
  }

  // Добавим несколько базовых объектов
  addPhysicalBox(new THREE.Vector3(2,6,-2), new THREE.Vector3(1,1,1), 0xff3333);
  addPhysicalBox(new THREE.Vector3(-3,8,1), new THREE.Vector3(1.6,0.6,1), 0x33ff88);
  addPhysicalSphere(new THREE.Vector3(0,10,0), 0.7, 0x3399ff);

  // --- Время (остановка времени) ---
  let timeStopped = false;
  const timeBtn = document.getElementById('timeBtn');
  timeBtn.addEventListener('click', ()=>{ 
    timeStopped = !timeStopped; 
    timeBtn.textContent = timeStopped? 'Время: ПАУЗА' : 'Остановить время'; 
    timeBtn.style.color = timeStopped ? '#ffcc00' : '#fff';
  });

  // --- Перетаскивание объектов ---
  let draggedObject = null;
  let dragOffset = new THREE.Vector3(); // Смещение от центра объекта до точки касания
  let dragDistance = 0; // Расстояние от камеры до перетаскиваемого объекта

  function startDragging(obj, point) {
    draggedObject = obj;
    // Делаем тело статичным для прямого управления позицией
    draggedObject.body.mass = 0;
    draggedObject.body.type = CANNON.Body.STATIC;
    draggedObject.body.updateMassProperties();
    draggedObject.body.quaternion.set(0,0,0,1); // Сбрасываем вращение
    draggedObject.mesh.quaternion.set(0,0,0,1);

    dragOffset.subVectors(obj.mesh.position, point);
    dragDistance = camera.position.distanceTo(obj.mesh.position);
    
    // Визуальная обратная связь
    if (draggedObject.mesh.material.emissive) {
        draggedObject.mesh.material.emissive.setHex(0x333333);
    }
  }

  function stopDragging() {
    if (draggedObject) {
      draggedObject.body.mass = 1;
      draggedObject.body.type = CANNON.Body.DYNAMIC;
      draggedObject.body.updateMassProperties();
      draggedObject.body.wakeUp();

      // Сбрасываем визуальную обратную связь
      if (draggedObject.mesh.material.emissive) {
          draggedObject.mesh.material.emissive.setHex(0x000000);
      }
      draggedObject = null;
    }
  }

  function updateDraggedObject(screenX, screenY) {
    if (!draggedObject) return;

    // Преобразуем координаты экрана в нормированные координаты устройства (NDC)
    const mouse = new THREE.Vector2(
      (screenX / window.innerWidth) * 2 - 1,
      -(screenY / window.innerHeight) * 2 + 1
    );

    // Устанавливаем луч из камеры
    raycaster.setFromCamera(mouse, camera);

    // Расчет точки в 3D-пространстве на заданном расстоянии от камеры
    const targetPoint = new THREE.Vector3();
    raycaster.ray.at(dragDistance, targetPoint); // Используем сохраненное расстояние

    // Применяем смещение
    targetPoint.add(dragOffset);

    // Ограничиваем Y, чтобы объект не улетал слишком высоко или низко
    targetPoint.y = Math.max(0.5, Math.min(20, targetPoint.y));

    draggedObject.mesh.position.copy(targetPoint);
    draggedObject.body.position.set(targetPoint.x, targetPoint.y, targetPoint.z);
  }

  // --- Редактор (открытие/закрытие) ---
  const editorPanel = document.getElementById('editorPanel');
  document.getElementById('openEditor').addEventListener('click', ()=>{
    editorPanel.style.display='flex';
  });

  // --- Режим создания объектов по тапу ---
  let createMode = false;
  const addPrimBtn = document.getElementById('addPrim');
  addPrimBtn.addEventListener('click', ()=>{
    createMode = !createMode;
    addPrimBtn.classList.toggle('active', createMode);
    addPrimBtn.textContent = createMode ? 'Отменить создание' : 'Создать объект';
  });
  // При закрытии редактора, отключаем режим создания
  document.getElementById('closeEditor').addEventListener('click', ()=>{
    editorPanel.style.display='none';
    if (createMode) {
      createMode = false;
      addPrimBtn.classList.remove('active');
      addPrimBtn.textContent = 'Создать объект';
    }
  });


  // --- Виртуальный джойстик (управление) ---
  const joy = document.getElementById('joystick');
  const joyIndicator = joy.querySelector('::before');
  let joyState = {active:false, x:0, y:0};
  
  joy.addEventListener('touchstart', (e)=>{joyState.active=true; e.preventDefault(); updateJoystick(e.touches[0]);}, {passive: false});
  joy.addEventListener('touchend', (e)=>{
    joyState.active=false; 
    joyState.x=0; 
    joyState.y=0; 
    e.preventDefault();
    if (joyIndicator) joyIndicator.style.transform = 'translate(-50%, -50%)';
  }, {passive: false});
  joy.addEventListener('touchmove', (e)=>{
    if (!joyState.active) return;
    e.preventDefault();
    updateJoystick(e.touches[0]);
  }, {passive: false});

  function updateJoystick(touch) {
    const r = joy.getBoundingClientRect();
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    const dx = (touch.clientX - cx)/ (r.width/2);
    const dy = (touch.clientY - cy)/ (r.height/2);
    joyState.x = Math.max(-1, Math.min(1, dx));
    joyState.y = Math.max(-1, Math.min(1, dy));

    if (joyIndicator) {
        joyIndicator.style.transform = `translate(${joyState.x * 35 - 50}%, ${joyState.y * 35 - 50}%)`; // Уменьшил диапазон движения
    }
  }

  const upBtn = document.getElementById('upBtn');
  const downBtn = document.getElementById('downBtn');
  let ascend=0;
  upBtn.addEventListener('touchstart', (e)=>{ascend=1; e.preventDefault();}, {passive: false}); 
  upBtn.addEventListener('touchend', (e)=>{ascend=0; e.preventDefault();}, {passive: false});
  downBtn.addEventListener('touchstart', (e)=>{ascend=-1; e.preventDefault();}, {passive: false}); 
  downBtn.addEventListener('touchend', (e)=>{ascend=0; e.preventDefault();}, {passive: false});


  function getForwardVector(){
    const v = new THREE.Vector3(0,0,-1);
    v.applyQuaternion(player.mesh.quaternion);
    return v.normalize();
  }
  
  function handlePlayer(dt){
    const turnSpeed = 1.5;
    player.mesh.rotation.y -= joyState.x * turnSpeed * dt;

    const moveSpeed = 6;
    const forward = getForwardVector();
    const moveZ = forward.clone().multiplyScalar(-joyState.y * moveSpeed * dt);
    
    player.mesh.position.add(moveZ);
    player.mesh.position.y += ascend * 4 * dt;
    
    if(player.mesh.position.y < 1.6) player.mesh.position.y = 1.6;
  }

  // --- Главный цикл ---
  let last = performance.now();
  const fixedTimeStep = 1 / 60; 

  function animate(){
    requestAnimationFrame(animate);

    const now = performance.now();
    let dt = (now - last) / 1000;
    last = now;

    if (dt > 0.1) dt = 0.1; 

    handlePlayer(dt);

    if(!timeStopped){
      world.step(fixedTimeStep, dt, 3);
      for(const d of dynamic){
        // Только если объект не перетаскивается
        if (d !== draggedObject) { 
          d.mesh.position.copy(d.body.position);
          d.mesh.quaternion.copy(d.body.quaternion);
        }
      }
    }

    renderer.render(scene, camera);
  }
  animate();

  // --- Адаптация к размеру ---
  window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // --- Оптимизация ---
  renderer.shadowMap.enabled = false;
  if(window.devicePixelRatio>2) renderer.setPixelRatio(2);
  
  // --- Управление жестами: Long Press для перетаскивания, Tap для создания ---
  
  let lastTouchY = null;
  let isControllingUI = false;
  let touchStartTime = 0;
  let initialTouchPoint = {x:0, y:0};
  const LONG_PRESS_TIME = 300; // ms
  const DRAG_THRESHOLD = 5; // pixels
  let isLongPress = false;
  let currentTouchObject = null; // Объект, на который началось касание

  // ИСПРАВЛЕНО: Слушатель на весь документ
  document.addEventListener('touchstart', (e) => {
    // Отменяем, если мультитач
    if (e.touches.length > 1) {
      isControllingUI = true; // Блокируем камеру
      lastTouchY = null;
      touchStartTime = 0;
      return;
    }

    const touch = e.touches[0];
    initialTouchPoint = {x: touch.clientX, y: touch.clientY};
    touchStartTime = performance.now();
    
    const target = e.target;
    // Проверяем, не началось ли касание на одном из элементов UI
    if (target.closest('#joystick') || target.closest('#thruster') || target.closest('.hud') || target.closest('#editorPanel')) {
      isControllingUI = true;
      lastTouchY = null;
    } else {
      isControllingUI = false;
      lastTouchY = touch.clientY;

      // Проверяем, попали ли на объект для перетаскивания
      const mouse = new THREE.Vector2(
        (touch.clientX / window.innerWidth) * 2 - 1,
        -(touch.clientY / window.innerHeight) * 2 + 1
      );
      raycaster.setFromCamera(mouse, camera);
      const meshes = dynamic.map(d=>d.mesh);
      const intersects = raycaster.intersectObjects(meshes);

      if (intersects.length > 0) {
        currentTouchObject = dynamic.find(d => d.mesh === intersects[0].object);
        // Сохраняем dragOffset для точного захвата
        dragOffset.subVectors(currentTouchObject.mesh.position, intersects[0].point);
        dragDistance = camera.position.distanceTo(currentTouchObject.mesh.position);
      } else {
        currentTouchObject = null;
      }
    }
  }, {passive: false});

  // ИСПРАВЛЕНО: Движение
  document.addEventListener('touchmove', (e) => {
    if (e.touches.length > 1 || isControllingUI) {
      lastTouchY = null;
      return;
    }

    const touch = e.touches[0];
    const dx = touch.clientX - initialTouchPoint.x;
    const dy = touch.clientY - initialTouchPoint.y;
    const distanceMoved = Math.sqrt(dx*dx + dy*dy);

    // Логика Long Press / Dragging:
    if (currentTouchObject && !isLongPress) {
      const isTimePassed = performance.now() - touchStartTime > LONG_PRESS_TIME;
      const isMovedEnough = distanceMoved > DRAG_THRESHOLD;

      // Активируем перетаскивание, если прошло время ИЛИ если движение было достаточным (для более отзывчивого перетаскивания)
      if (isTimePassed || isMovedEnough) {
          isLongPress = true;
          startDragging(currentTouchObject, currentTouchObject.mesh.position);
      }
    }

    if (draggedObject) {
        updateDraggedObject(touch.clientX, touch.clientY);
        e.preventDefault(); // Предотвращаем скролл/масштаб во время перетаскивания
    } else if (lastTouchY !== null) { // Если не перетаскиваем и не UI, то вращаем камеру
      const deltaY = touch.clientY - lastTouchY;
      lastTouchY = touch.clientY;
      
      camera.rotation.x += deltaY * 0.003; 
      camera.rotation.x = Math.max(-1.4, Math.min(1.4, camera.rotation.x));
      e.preventDefault(); // Предотвращаем скролл/масштаб во время вращения
    }
  }, {passive: false});

  // ИСПРАВЛЕНО: Конец касания
  document.addEventListener('touchend', (e) => {
    // Если отпустили палец и это не был long press/drag, это короткий тап
    if (e.touches.length === 0 && !isControllingUI && !isLongPress) {
        const tapDuration = performance.now() - touchStartTime;
        const dx = e.changedTouches[0].clientX - initialTouchPoint.x;
        const dy = e.changedTouches[0].clientY - initialTouchPoint.y;
        const distanceMoved = Math.sqrt(dx*dx + dy*dy);

        // Если это был короткий тап (не лонг-пресс и не сильное движение)
        if (tapDuration < LONG_PRESS_TIME && distanceMoved < DRAG_THRESHOLD) {
            // Если режим создания активен, создаем объект
            if (createMode) {
                const mouse = new THREE.Vector2(
                    (initialTouchPoint.x / window.innerWidth) * 2 - 1,
                    -(initialTouchPoint.y / window.innerHeight) * 2 + 1
                );
                raycaster.setFromCamera(mouse, camera);
                // Проецируем на плоскость Y=0 или на объекты
                const intersects = raycaster.intersectObjects([groundMesh].concat(dynamic.map(d=>d.mesh)));
                if (intersects.length > 0) {
                    const intersectionPoint = intersects[0].point;
                    const type = document.getElementById('primType').value;
                    const color = document.getElementById('primColor').value;
                    
                    // Немного поднимаем объект над точкой касания
                    // Учитываем высоту, чтобы объект не проваливался
                    const objectHeight = type === 'box' ? 1 : 0.6; // Высота/радиус по умолчанию
                    intersectionPoint.y += objectHeight / 2 + 0.01; 
                    
                    if(type==='box') addPhysicalBox(intersectionPoint, new THREE.Vector3(1,1,1), color);
                    else addPhysicalSphere(intersectionPoint, 0.6, color);
                }
            }
        }
    }
    
    stopDragging(); // Всегда останавливаем перетаскивание при отпускании
    lastTouchY = null;
    isControllingUI = false;
    touchStartTime = 0;
    isLongPress = false;
    currentTouchObject = null;
  });

</script>
</body>
</html>
